<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Content tagged as &#39;Requirejs&#39; on BinaryMist</title>
    <link>https://binarymist.io/tags/requirejs/</link>
    <description>Recent content in Content tagged as &#39;Requirejs&#39; on BinaryMist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 BinaryMist Ltd &lt;/br&gt;Following images are used under Creative Commons: [1](https://www.flickr.com/photos/ravefinity/12180959354/in/photostream/) &lt;/br&gt;[Privacy](/publication/privacy/)</copyright>
    <lastBuildDate>Fri, 01 Jan 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://binarymist.io/tags/requirejs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Node.js Asynchronicity and Callback Nesting</title>
      <link>https://binarymist.io/blog/2014/07/26/node.js-asynchronicity-and-callback-nesting/</link>
      <pubDate>Sat, 26 Jul 2014 00:00:00 +1200</pubDate>
      
      <guid>https://binarymist.io/blog/2014/07/26/node.js-asynchronicity-and-callback-nesting/</guid>
      <description>&lt;p&gt;Redirects to legacy blog post.&lt;/p&gt;

&lt;p&gt;AKA callback hell, temple of doom, often the functions that are nested are anonymous and often they are implicit closures. When it comes to asynchronicity in JavaScript, callbacks are our bread and butter. In saying that, often the best way to use them is by abstracting them behind more elegant APIs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Evaluation of AngularJS, EmberJS, BackboneJS &#43; MarionetteJS</title>
      <link>https://binarymist.io/blog/2013/12/28/evaluation-of-angularjs-emberjs-backbonejs-marionettejs/</link>
      <pubDate>Sat, 28 Dec 2013 00:00:00 +1300</pubDate>
      
      <guid>https://binarymist.io/blog/2013/12/28/evaluation-of-angularjs-emberjs-backbonejs-marionettejs/</guid>
      <description>&lt;p&gt;Redirects to legacy blog post.&lt;/p&gt;

&lt;p&gt;Recently I’ve undertaken the task of reviewing some JavaScript MV* frameworks to help organise/structure the client side code within an application I’m currently working on. This is about the third time I’ve done this. Each time has been for a different type of application with completely different requirements, frameworks and libraries to consider. Unlike Angular and Ember, Backbone is a small library. Marionette adds quite a lot of extra functionality and provides some nice abstractions on top . All mentioned frameworks/libraries are free and open source.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>